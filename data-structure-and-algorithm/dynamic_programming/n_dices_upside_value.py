import math

from time import time

# brute force implementation, creating a generator to permute the sum of n dices upside numbers.
def gen_n_dices(n):
  if n == 1:
    for value in range(1,7):
      yield value
    return
  for value in range(1,7):
    for rest_values in gen_n_dices(n-1):
      yield value + rest_values

def bt_n_dices_prob(n):
  g = gen_n_dices(n)
  counts = {}
  for sum in g:
    try:
      counts[sum] +=1
    except KeyError:
      counts[sum] =1
  total = math.pow(6, n)
  for sum, count in counts.items():
    counts[sum] = count/total * 100
  print(counts)

# dynamic programming implementation, using a counts{} dict to remember the occurrences of each sum result 
# generated from the permutations of n-1 numbers of dices' upside number.
# start from only 1 dice(1), the sums of upside are [1,2,3,4,5,6], the occurrences of sums are [1,1,1,1,1,1],
# then the counts(1) = {1:1, 2:1, 3:1, 4:1, 5:1, 6:1} 
# consider 2 dices, the first sum is 2, its occurrence equal to the result of add up the occurrences of the
# sums in the counts(1) which when add to any possible upside number of dice(2) equal to 2, here only the 
# pair {1:1} in the previous count(1) math the rule, so the occurrences of the sum == 2 is 1. but the next 
# sum, 3, could reach frame adding up current upside 1 with previous sum 2 and current upside 2 with previous
# sum 1, so the occurrences of sum == 3 equal to adds up the value of {1:1} and {2:1}, is 2.
# to generalize the rule, each sum of current counts(n) generated by any possible upside number of dice(n)
# plus the sums of previous counts(n-1), the occurrences of each new generated sum equals to the result that 
# adds up all the occurrences of the sums in the previous counts(n-1) which when add to a possible upside number
# of dice(n) equal to the new generated sum.

def dp_n_dices(n):
  counts = dict()
  if n == 1:
    for sum in range(1,7):
      counts[sum] = 1
    return counts
  pre_counts = dp_n_dices(n-1)
  for i in range(1,7):
    for sum, count in pre_counts.items(): 
      try:
        counts[i+sum] += count
      except KeyError:
        counts[i+sum] = count
  return counts

def dp_n_dices_prob(n):
  counts = dp_n_dices(n)
  total = math.pow(6,n)
  for sum, count in counts.items():
    counts[sum] = count/total * 100
  print(counts) 
  
if __name__ == '__main__':
  n = 9
  t0 = time()
  bt_n_dices_prob(n)
  t1 = time()
  dp_n_dices_prob(n)
  t2 = time()
  print(f'n = {n}, \ndynamic programming: {t2-t1}, \nbrute force: {t1-t0}.')